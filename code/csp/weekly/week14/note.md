# 动态规划（三）
* 区间DP--线性动态规划拓展，大区间分割成小区间
    * 石子合并
    * 括号序列
    * 最长回文子序列
* 状压DP--高维压缩成2进制，整数表示二进制
    * 作业规划
    * 棋盘分割
## 区间DP
### 石子合并
* n堆石子排成一排，合并n-1次，令代价最小
* 贪心 x
* $f[][]=sum[i][j]+min{f[i][k]+f[k+1][j]}(i<=k<j)$
* 时间复杂度：状态量*转移复杂度 $n^2*n$ ，前缀和$sum[i][j]=sum[j]-sum[i-1]$
* 步骤
    * 初始化
    * 转移
    * 找到最终答案
* 解决
    * 自上而下 递归-机器化搜索
    * 自下而上 递推-已知推位置
```cpp
memset(f,63,sizeof f);0x3f
for(int i=1;i<=n;++i) f[i][i]=0;
for(int len =2;len<)
```
* 环形排列？
    * 拆开-->$O(n^4)$
    * 拆环为链-->$O(n^3)$ answet:min(f[i],f[i+n-1])
### 括号序列
* 栈
* s合法，(s)/[s]合法
* f[i][j]=min{f[i][k]+f[k+1][j]}
* f[i][j]=min{f[i][j],f[i+1][j-1]}
* 初始化，长度为1答案为1，长度为0大难为0
* 匹配
    * 不匹配f[i][j]=min{f[i][k]+f[k+1][j]}
    * 匹配f[i][j]=min{f[i][j],f[i+1][j-1]}
* answer：f[1][n]
### 最长回文子序列
可以不连续，奇数长度/偶数长度
* 字串
    * bool f[i][j]
    * f[i][j]=f[i+1][j-1]&(str[i]==str[j])
    * max(j-i+1) f[i][j]==1
* 子序列
    * 长度为1一定是最长回文子序列
    * 匹配
        * f[i][j]=max(f[i+1][j],f[i][j-1])
        * f[i][j]=f[i+1][j-1]+2
    * f[1][n]
* 状态量*转移复杂度，$O(n^2)$
## 状压DP
* S
    * S&(1<<i) 非0就是存在的
    * S=S | （1<<i) 添加1个位
    * S=S ^ (1<<i) 删除，存在后再删
* hh
    * %2==&1
    * /2==>>1
### 作业
### 多米诺骨牌
* h，w分隔为1/2的长方形，有多少种方案
* 不向下衍生/向下延申
* f[i][s]表示填充到了第i行